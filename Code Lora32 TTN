#include <lmic.h>
#include <hal/hal.h>
#include <SPI.h>
#include <CayenneLPP.h>
#include <Wire.h>

float temp, pa, hum, alt;
int cnt = 0;
bool loraConnected = false;
unsigned long lastSuccessMillis = 0;
int failedTxCount = 0;
const int MAX_FAILED_TX = 3;
const unsigned long CONNECTION_TIMEOUT = 60000; // 60s

static const u1_t PROGMEM APPEUI[8]= { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
void os_getArtEui (u1_t* buf) { memcpy_P(buf, APPEUI, 8); }

static const u1_t PROGMEM DEVEUI[8]=  { 0x9F, 0x00, 0x07, 0xD0, 0x7E, 0xD5, 0xB3, 0x70 };
void os_getDevEui (u1_t* buf) { memcpy_P(buf, DEVEUI, 8); }

static const u1_t PROGMEM APPKEY[16] = { 0x84, 0x3F, 0x30, 0x48, 0xD9, 0x89, 0xAA, 0x86, 0x84, 0xB9, 0xB3, 0xBE, 0xBB, 0x64, 0x1B, 0x7E };
void os_getDevKey (u1_t* buf) {  memcpy_P(buf, APPKEY, 16); }

static osjob_t sendjob;
const unsigned TX_INTERVAL = 10;
CayenneLPP lpp(51);

// === HAL ===
class cHalConfiguration_t: public Arduino_LMIC::HalConfiguration_t {
public:
    virtual u1_t queryBusyPin(void) override { return 13; };
    virtual bool queryUsingDcdc(void) override { return true; };
    virtual bool queryUsingDIO2AsRfSwitch(void) override { return true; };
    virtual bool queryUsingDIO3AsTCXOSwitch(void) override { return true; };
};

cHalConfiguration_t myConfig;

const lmic_pinmap lmic_pins = {
    .nss = 8,
    .rxtx = LMIC_UNUSED_PIN,
    .rst = 12,
    .dio = {14, LMIC_UNUSED_PIN, LMIC_UNUSED_PIN},
    .rxtx_rx_active = 0,
    .rssi_cal = 10,
    .spi_freq = 8000000,
    .pConfig = &myConfig,
};

void printHex2(unsigned v) {
    v &= 0xff;
    if (v < 16) Serial.print('0');
    Serial.print(v, HEX);
}

void updateLoRaStatus(bool success) {
  if (success) {
    loraConnected = true;
    failedTxCount = 0;
    lastSuccessMillis = millis();
  } else {
    failedTxCount++;
    if (failedTxCount >= MAX_FAILED_TX || (millis() - lastSuccessMillis > CONNECTION_TIMEOUT)) {
      loraConnected = false;
    }
  }
}

void showLoRaStatus() {
  if (loraConnected) {
    Serial.println("[LoRa] ‚úÖ Connect√©");
  } else {
    Serial.println("[LoRa] ‚ùå Perte de connexion");
  }
}

void onEvent(ev_t ev) {
  Serial.print(os_getTime());
  Serial.print(": ");
  switch(ev) {
    case EV_JOINING:
      Serial.println(F("EV_JOINING"));
      break;

    case EV_JOINED:
      Serial.println(F("EV_JOINED"));
      updateLoRaStatus(true);
      {
        u4_t netid = 0;
        devaddr_t devaddr = 0;
        u1_t nwkKey[16];
        u1_t artKey[16];
        LMIC_getSessionKeys(&netid, &devaddr, nwkKey, artKey);
        Serial.print("netid: ");
        Serial.println(netid, DEC);
        Serial.print("devaddr: ");
        Serial.println(devaddr, HEX);
        Serial.print("AppSKey: ");
        for (size_t i=0; i<sizeof(artKey); ++i) {
          if (i != 0) Serial.print("-");
          printHex2(artKey[i]);
        }
        Serial.println();
        Serial.print("NwkSKey: ");
        for (size_t i=0; i<sizeof(nwkKey); ++i) {
          if (i != 0) Serial.print("-");
          printHex2(nwkKey[i]);
        }
        Serial.println();
      }
      LMIC_setLinkCheckMode(0);
      break;

    case EV_TXCOMPLETE:
      Serial.println(F("EV_TXCOMPLETE"));
      updateLoRaStatus(true);
      if (LMIC.txrxFlags & TXRX_ACK) {
        Serial.println(F("ACK re√ßu"));
      }
      if (LMIC.dataLen) {
        Serial.print(F("Payload re√ßu : "));
        Serial.println(LMIC.dataLen);
      }
      os_setTimedCallback(&sendjob, os_getTime()+sec2osticks(TX_INTERVAL), do_send);
      break;

    case EV_TXCANCELED:
    case EV_JOIN_FAILED:
    case EV_REJOIN_FAILED:
    case EV_JOIN_TXCOMPLETE:
    case EV_LINK_DEAD:
      Serial.println(F("‚ö†Ô∏è √âchec de transmission ou Join"));
      updateLoRaStatus(false);
      break;

    case EV_TXSTART:
      Serial.println(F("EV_TXSTART"));
      break;

    default:
      Serial.print(F("Unknown event: "));
      Serial.println((unsigned) ev);
      break;
  }
}

void do_send(osjob_t* j) {
  if (LMIC.opmode & OP_TXRXPEND) {
    Serial.println(F("OP_TXRXPEND, not sending"));
  } else {
    temp = 4.69;
    hum = 74;

    Serial.print("Temp: ");
    Serial.print(temp);
    Serial.println(" C");

    Serial.print("Hum: ");
    Serial.print(hum);
    Serial.println(" %");

    lpp.reset();
    lpp.addTemperature(2, temp);
    lpp.addRelativeHumidity(3, hum);

    LMIC_setTxData2(2, lpp.getBuffer(), lpp.getSize(), 0);
    Serial.println(F("Packet queued"));

    showLoRaStatus(); // üîÅ Affiche √©tat actuel √† chaque envoi
  }
}

void setup() {
  Serial.begin(115200);
  Serial.println(F("Starting..."));

  os_init();
  LMIC_reset();
  lastSuccessMillis = millis(); // d√©marrage initial
  do_send(&sendjob);
}

void loop() {
  os_runloop_once();
}
